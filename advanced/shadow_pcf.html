<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>点光源阴影立方体动画</title>
<style>
    body{margin: 0;}
</style>
</head>
<body>
<canvas id="canvas" width="500" height="500"></canvas>
<script src="../js/webgl.js"></script>
<script src="../js/matrix.js"></script>
<script type="x-shader/x-vertex" id="svs">
    attribute vec4 a_position; 
    uniform mat4 u_mvpMatrix; 
    void main() { 
        gl_Position = u_mvpMatrix * a_position; 
    }
</script>
<script type="x-shader/x-fragment" id="sfs">
    #ifdef GL_ES
        precision highp float;
    #endif
    /**
     * 获取分解后的深度值
     * @param  {float} float depth
     * @return {float}      
     */
    vec4 packDepth (float depth) {
        // 使用rgba 4字节共32位来存储z值,1个字节精度为1/256
        const vec4 bitShift = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);
        const vec4 bitMask = vec4(1.0/256.0, 1.0/256.0, 1.0/256.0, 0.0);
        // gl_FragCoord:片元的坐标,fract():返回数值的小数部分
        vec4 rgbaDepth = fract(depth * bitShift); //计算每个点的z值 
        rgbaDepth -= rgbaDepth.gbaa * bitMask; // Cut off the value which do not fit in 8 bits
        return rgbaDepth;
    }
    void main() {
        gl_FragColor = packDepth(gl_FragCoord.z);// 将z值分开存储到rgba分量中,阴影颜色的同时也是深度值z
    }
</script>
<script type="x-shader/x-vertex" id="vs">
    attribute vec4 a_position;
    attribute vec4 a_color;
    attribute vec4 a_normals;
    uniform mat4 u_modelMatrix;//等比例变换,可以用模型矩阵代替逆转置矩阵
    uniform mat4 u_mvpMatrix;//当前视点观测的模型视图投影矩阵
    uniform mat4 u_mvpMatrixFromLight;//光源处观察的模型视图投影矩阵
    varying vec4 v_positionFromLight;
    varying vec3 v_position;
    varying vec3 v_normals;
    varying vec4 v_color;
    void main() {
        gl_Position = u_mvpMatrix * a_position; // 当前视点观察到的坐标
        v_positionFromLight = u_mvpMatrixFromLight * a_position;//光源处观察到的坐标,用于后续分解出z值
        v_color = a_color;
        v_position = vec3(u_modelMatrix * a_position);
        v_normals = vec3(u_modelMatrix * a_normals);
    }
</script>
<script type="x-shader/x-fragment" id="fs">
    #ifdef GL_ES
        precision highp float;
    #endif
    uniform vec3 u_lightColor;
    uniform vec3 u_lightPosition;
    uniform vec3 u_ambientColor;
    uniform sampler2D u_shadowMap;

    varying vec4 v_positionFromLight;
    varying vec3 v_position;
    varying vec3 v_normals;
    varying vec4 v_color;  

    /**
     * 释出深度值z
     */
    float unpackDepth(const in vec4 rgbaDepth) {
        const vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0*256.0), 1.0/(256.0*256.0*256.0));
        return dot(rgbaDepth, bitShift);
    }

    void main() {
        // 对法线归一化，因为其内插之后长度不一定是1
        vec3 normal = normalize(v_normals);
        // 计算光线方向(光源位置-顶点位置)并归一化
        vec3 lightDirection = normalize(u_lightPosition - v_position.xyz);
        // 计算光线方向和法向量点积
        float nDotL = max(dot(lightDirection, normal), 0.0);

        // 计算漫反射亮度
        vec3 diffuse = u_lightColor * v_color.rgb * nDotL;
        // 计算环境光亮度
        vec3 ambient = u_ambientColor * v_color.rgb;
        
        vec3 eyeDirection = vec3(0.0,0.0,1.0);
        // vec3 eyeDirection = normalize(-v_position.xyz);// 反射方向
        vec3 reflectionDirection = reflect(-lightDirection, normal);
        vec3 specularColor =vec3(1.0,1.0,1.0);//镜面反射光颜色
        // 镜面反射亮度权重
        float specularWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), 50.0);
        // 计算镜面高光亮度
        vec3 specular =  specularColor.rgb * specularWeighting * (nDotL<=0.0?0.0:1.0);

        // 这是gl_FragCoord坐标的计算方式(返回结果已经归一化),因为阴影纹理坐标和该坐标(光源处观察到的坐标),视点都是在光源处(使用的都是光源处的mvp矩阵);
        // 所以使用该坐标计算出的就是纹理的坐标, 再通过纹理坐标就能找到对应的z值
        vec3 shadowCoord = (v_positionFromLight.xyz/v_positionFromLight.w)/2.0 + 0.5;
        // float visibility = (shadowCoord.z > depth + 0.0015) ? 0.6 : 1.0;//大于阴影的z轴,说明在阴影中并显示为阴影*0.6,否则为正常颜色*1.0
        float shadow = 1.0;
        if ( v_positionFromLight.w > 0.0 )  {
            shadow = 0.0;
            for(float y=-1.5; y <= 1.5; y += 1.0){
                for(float x=-1.5; x <=1.5; x += 1.0){
                    vec4 rgbaDepth = texture2D(u_shadowMap, shadowCoord.xy+vec2(x,y));
                    shadow += float(shadowCoord.z < unpackDepth(rgbaDepth));
                }
            }      
            shadow /= 16.0;// 4*4
            shadow += 0.5;
        }
        gl_FragColor = vec4((diffuse + ambient + specular)*shadow, v_color.a);
    }
</script>
<script>
// 阴影贴图是一种使用深度纹理来为渲染阴影提供解决方案的多通道计算。
// 它的关键是，就是用投射光源代替最终视口来观察场景。通过移动视口到光源位置，可以观察到这个位置每个东西都是明亮的，因为从光的角度来看是没有阴影的。
// 从光源的角度将场景的深度渲染到一张深度缓冲区中，我们可以在场景中获得一张阴影或者无阴影的贴图.

var canvas = document.getElementById('canvas'),
    gl = get3DContext(canvas),
    OFFSCREEN_WIDTH = 2048,
    OFFSCREEN_HEIGHT = 2048,
    LIGHT_POS=[4,3,6],
    VIEW_POS=[0,6,12];

function main() {
    if (!gl) {
        console.log('Failed to get the rendering context for WebGL');
        return;
    }

    // 初始化阴影着色器,创建对应program
    var shadowProgram=createProgramInfo(gl,['svs','sfs'],['a_position']);

    // 初始化普通着色器,创建对应program
    var normalProgram=createProgramInfo(gl,['vs','fs'],['a_position','a_color','a_normals']);

    // 获取对应图形的缓冲区对象
    var planeBuffers = initBuffersForPlane(gl);
    var cubeBuffers = initBuffersForCube(gl);

    // 初始化帧缓冲区对象 (FBO)  
    var fbo = initFramebufferObject(gl);
    if (!fbo) {
        console.log('Failed to initialize frame buffer object');
        return;
    }

    // 激活0号纹理单元,并将纹理对象绑定到该单元
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, fbo.texture);

    // 设置背景设并开启隐藏面消除功能 
    gl.clearColor(0, 0, 0, 1);
    gl.enable(gl.DEPTH_TEST);
    // gl.enable(gl.CULL_FACE);

    var viewProjMatrixFromLight = new Matrix4(); // 光源处观察的视图投影矩阵(阴影着色器)
    viewProjMatrixFromLight.setPerspective(90, OFFSCREEN_WIDTH / OFFSCREEN_HEIGHT, 1.0, 100.0);
    viewProjMatrixFromLight.lookAt(...LIGHT_POS, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);

    var viewProjMatrix = new Matrix4(); // 当前视点观测的视图投影矩阵(正常着色器)
    viewProjMatrix.setPerspective(35, canvas.width / canvas.height, 1.0, 100.0);
    viewProjMatrix.lookAt(...VIEW_POS, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);

    var mvpMatrixFromLight_c = new Matrix4(); // 从光源处观察立方体的mvp矩阵(正常着色器)
    var mvpMatrixFromLight_p = new Matrix4(); // 从光源处观察平面的mvp矩阵(正常着色器)
    var mvpMatrix = new Matrix4();// 通用mvp矩阵
    var modelMatrix = new Matrix4();// 模型矩阵(正常着色器)

    var angle=0,ANGLE_STEP = 40, last = Date.now();
    (function animate(){
        var now = new Date(),
            elapsed = now - last;

        last = now;
        angle += ANGLE_STEP * elapsed / 1000;
        angle %= 360;

        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo); // 切换绘制场景为帧缓冲区  
        gl.viewport(0, 0, OFFSCREEN_HEIGHT, OFFSCREEN_HEIGHT); // 设置帧绘图区域
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // Clear FBO    
        
        /*
         *   阴影着色器
         */ 
        gl.useProgram(shadowProgram.program);
        // 绘制立方体
        drawCube(shadowProgram,viewProjMatrixFromLight);
        // 绘制平面
        drawPlane(shadowProgram,viewProjMatrixFromLight);

        // 将帧缓冲区切换为正常的缓冲区
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, canvas.width, canvas.height);//设置绘图区域
         // 清屏和深度缓冲
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
        /*
         *  正常的着色器
         */ 
        gl.useProgram(normalProgram.program);

        normalProgram.setUniforms({
            u_shadowMap: '0', // 传递0号纹理:gl.TEXTURE0
            u_lightColor: [1,1,1],// 光照颜色
            u_lightPosition: LIGHT_POS, // 光线方向(世界坐标系下)
            u_ambientColor:[0.2,0.2,0.2] // 环境光颜色
        });

        // 绘制立方体        
        drawCube(normalProgram,viewProjMatrix);
        // 绘制平面
        drawPlane(normalProgram,viewProjMatrix);

        requestAnimationFrame(animate);
    }());

    function drawCube(program,vpMatrix){
        modelMatrix.setTranslate( 1.5, -0.5, 2.5);
        modelMatrix.rotate(angle, 0, 1, 0);
        mvpMatrix.set(vpMatrix);
        mvpMatrix.multiply(modelMatrix);
        if(program==shadowProgram){
            mvpMatrixFromLight_c.set(mvpMatrix);
        } else {
            program.setUniforms({
                u_mvpMatrixFromLight: mvpMatrixFromLight_c.elements,
                u_modelMatrix: modelMatrix.elements
            });
        }
        draw(gl, program, cubeBuffers,mvpMatrix);
    }

    function drawPlane(program,vpMatrix){
        modelMatrix.setRotate(10, 1, 0, 0);
        // modelMatrix.setIdentity();
        mvpMatrix.set(vpMatrix);
        mvpMatrix.multiply(modelMatrix);
        if(program==shadowProgram){
            mvpMatrixFromLight_p.set(mvpMatrix);
        } else {
            program.setUniforms({
                u_mvpMatrixFromLight: mvpMatrixFromLight_p.elements,
                u_modelMatrix: modelMatrix.elements
            });
        }
        draw(gl, program, planeBuffers,mvpMatrix);
    }
}


function draw(gl, program, buffer,mvpMatrix) {
    // 输出attribute对应的数据缓冲
    program.setBufferAttributes(buffer);
    program.setUniforms({u_mvpMatrix: mvpMatrix.elements});
    //输出顶点索引缓冲
    buffer.outputIndex();
    gl.drawElements(gl.TRIANGLES, buffer.num, gl.UNSIGNED_BYTE, 0);
}

function initBuffersForCube(gl) {
    // Create a cube
    //    v6----- v5
    //   /|      /|
    //  v1------v0|
    //  | |     | |
    //  | |v7---|-|v4
    //  |/      |/
    //  v2------v3
    //
    // 顶点
    var vertices = new Float32Array([
         1.0,3.0, 1.0,  -1.0, 3.0, 1.0,  -1.0, 1.0, 1.0,   1.0, 1.0, 1.0, // v0-v1-v2-v3 front
         1.0,3.0, 1.0,   1.0, 1.0, 1.0,   1.0, 1.0,-1.0,   1.0, 3.0,-1.0, // v0-v3-v4-v5 right
         1.0,3.0, 1.0,   1.0, 3.0,-1.0,  -1.0, 3.0,-1.0,  -1.0, 3.0, 1.0, // v0-v5-v6-v1 up
        -1.0,3.0, 1.0,  -1.0, 3.0,-1.0,  -1.0, 1.0,-1.0,  -1.0, 1.0, 1.0, // v1-v6-v7-v2 left
        -1.0,1.0,-1.0,   1.0, 1.0,-1.0,   1.0, 1.0, 1.0,  -1.0, 1.0, 1.0, // v7-v4-v3-v2 down
         1.0,1.0,-1.0,  -1.0, 1.0,-1.0,  -1.0, 3.0,-1.0,   1.0, 3.0,-1.0  // v4-v7-v6-v5 back
    ]);

    // 颜色
    var colors = new Float32Array([
        0.7, 0, 0,   0.7, 0, 0,   0.7, 0, 0,  0.7, 0, 0,     // v0-v1-v2-v3 front
        0.7, 0, 0,   0.7, 0, 0,   0.7, 0, 0,  0.7, 0, 0,     // v0-v3-v4-v5 right
        0.7, 0, 0,   0.7, 0, 0,   0.7, 0, 0,  0.7, 0, 0,     // v0-v5-v6-v1 up
        0.7, 0, 0,   0.7, 0, 0,   0.7, 0, 0,  0.7, 0, 0,     // v1-v6-v7-v2 left
        0.7, 0, 0,   0.7, 0, 0,   0.7, 0, 0,  0.7, 0, 0,     // v7-v4-v3-v2 down
        0.7, 0, 0,   0.7, 0, 0,   0.7, 0, 0,  0.7, 0, 0　    // v4-v7-v6-v5 back
    ]);

    // 法向量
    var normals = new Float32Array([
        0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,  // v0-v1-v2-v3 front
        1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,  // v0-v3-v4-v5 right
        0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,  // v0-v5-v6-v1 up
        -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  // v1-v6-v7-v2 left
        0.0,-1.0, 0.0,   0.0,-1.0, 0.0,   0.0,-1.0, 0.0,   0.0,-1.0, 0.0,  // v7-v4-v3-v2 down
        0.0, 0.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,-1.0   // v4-v7-v6-v5 back
    ]);

    // 顶点索引
    var indices = new Uint8Array([
         0, 1, 2,   0, 2, 3,    // front
         4, 5, 6,   4, 6, 7,    // right
         8, 9,10,   8,10,11,    // up
        12,13,14,  12,14,15,    // left
        16,17,18,  16,18,19,    // down
        20,21,22,  20,22,23     // back
    ]);
    return createBuffer(gl,{
        position:{data:vertices, num:3, type:gl.FLOAT },
        color:{data:colors, num:3, type:gl.FLOAT },
        normals:{data:normals, num:3, type:gl.FLOAT },
        indices:{data:indices, type:gl.UNSIGNED_BYTE }
    });
}

function initBuffersForPlane(gl) {
    // Create a plane
    //  v2------v3
    //  |        | 
    //  |        |
    //  |        |
    //  v1------v0
    //
    // 顶点
    var vertices = new Float32Array([
        4.0, -1, 4.0, 
        -5.0,-1, 4.0, 
        -5.0,-1, -10.0, 
        4.0, -1, -10.0 // v0-v1-v2-v3
    ]);
    // 颜色
    var colors = new Float32Array([
        1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0
    ]);
    // 顶点索引
    var indices = new Uint8Array([0, 1, 2, 0, 2, 3]);
    return createBuffer(gl,{
        position:{data:vertices, num:3, type:gl.FLOAT },
        color:{data:colors, num:3, type:gl.FLOAT },
        indices:{data:indices, type:gl.UNSIGNED_BYTE }
    });
}

main();
</script>
</body>

</html>
